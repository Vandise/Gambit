#include "cspec.h"
#include "cspec_output_header.h"
#include "cspec_output_verbose.h"
#include "cspec_output_unit.h"

#include "test/macros.h"
#include "modules/parser/parser_module.h"
#include "modules/scanner/scanner_module.h"
#include "modules/compiler/compiler_module.h"

#define OUT_FILE ".tmp/compiler_out.js"

extern int status;

COMPILER_STATUS_CODE test_compile_file(char* file_name) {
  Scanner* scanner = init_scanner(file_name);
  do {
    get_token(scanner);
    commit_token(scanner);
  } while (scanner->current_token.token != T_END_OF_FILE && scanner->current_token.token != T_ERROR);

  Parser* p = init_parser(get_tokens(scanner));
  parse(p);

  CompilerPtr compiler = init_compiler(OUT_FILE, p->root_node);

  COMPILER_STATUS_CODE status = compile(compiler);

  exit_parser(p);
  exit_scanner(scanner);
  exit_compiler(compiler);

  return status;
}

BOOLEAN test_file_contains(char* contents) {
  BOOLEAN infile = FALSE;
  char *line = NULL;
  size_t len = 0;
  ssize_t read;

  FILE *fp = fopen(OUT_FILE, "r");
  while ((read = getline(&line, &len, fp)) != -1) {
    line[strcspn(line, "\n")] = 0;
    if (!strcmp(line, contents)) {
      infile = TRUE;
      break;
    }
  }

  fclose(fp);

  return infile;
}

DESCRIBE(gambit_compiler_compile, "Compiler - compile")

--FILE noop_node.g--


--ENDFILE--
  IT("compiles NOOP nodes")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(noop_node.g)), OK);
  END_IT

--FILE core_load_node.g--

--ENDFILE--
  IT("compiles CORE_LOAD_NODE nodes")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(core_load_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("const match = require('./core/match');"));
    SHOULD_BE_TRUE(test_file_contains("const $ = match.parameter;"));
    SHOULD_BE_TRUE(test_file_contains("const _ = match.wildcard;"));
  END_IT

--FILE integer_literal_node.g--
80000
--ENDFILE--
  IT("compiles integer LITERAL nodes")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(integer_literal_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("80000"));
  END_IT

--FILE real_literal_node.g--
3.14159268
--ENDFILE--
  IT("compiles real LITERAL nodes")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(real_literal_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("3.141593"));
  END_IT

--FILE string_literal_node.g--
'hello world!'
--ENDFILE--
  IT("compiles real LITERAL nodes")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(string_literal_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("\"hello world!\""));
  END_IT

--FILE get_local_node.g--
my_variable
--ENDFILE--
  IT("compiles real GET_LOCAL nodes when found in the symbol table")
    // TODO:
    //  get_local is not yet defined and appears to be thought of as assignment in the statements
    //            need to work more on statements
    //SHOULD_EQUAL(test_compile_file(__TEST_FILE__(get_local_node_undefined.g)), OK);
  END_IT

--FILE binary_op_node.g--
10 >= 10
5 <= 2
1 > 3
2 < 3
--ENDFILE--
  IT("compiles BINARY_OP nodes")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(binary_op_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("(10>=10)(5<=2)(1>3)(2<3)"));
  END_IT

--FILE unary_op_node.g--
+5
--ENDFILE--
  IT("compiles real UNARY nodes when found in the symbol table")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(unary_op_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("(+5)"));
  END_IT

--FILE complex_binary_expressions.g--
(7 + 2) * 3
--ENDFILE--
  IT("compiles real complex math expressions")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(complex_binary_expressions.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("((7+2)*3)"));
  END_IT


--FILE variable_declaration_node.g--
let(x) = 5 * 3 + 2
--ENDFILE--
  IT("compiles simple VARIABLE DECLARATION nodes")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(variable_declaration_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("const x=((5*3)+2);"));
  END_IT

--FILE var_match_all_node.g--
let($x) = 'Bender'
--ENDFILE--
  IT("compiles simple VARIABLE DECLARATION match all nodes")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(var_match_all_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("const x=match([$,(x)=>x])(\"Bender\");"));
  END_IT

--FILE var_match_constant_node.g--
let($x:String) = 'Bender'
--ENDFILE--
  IT("compiles simple VARIABLE DECLARATION match constant nodes")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(var_match_constant_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("const x=match([String,(x)=>x])(\"Bender\");"));
  END_IT

--FILE var_match_value_strlit_node.g--
let($x:'Bender') = 'Bender'
--ENDFILE--
  IT("compiles simple VARIABLE DECLARATION match string literal nodes")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(var_match_value_strlit_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("const x=match([$(\"Bender\"),(x)=>x])(\"Bender\");"));
  END_IT

--FILE var_redcl_err_node.g--
let($x:'Bender') = 'Bender'
let($x:'Bender') = 'Bender'
--ENDFILE--
  IT("errors when a variable is re-bound")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(var_redcl_err_node.g)), REDECLARED_VARIABLE_BIND);
  END_IT

--FILE boolean_and_node.g--
5 && 1
--ENDFILE--
  IT("compiles AND expressions")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(boolean_and_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("(5&&1)"));
  END_IT

--FILE boolean_or_node.g--
5 || 1
--ENDFILE--
  IT("compiles OR expressions")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(boolean_or_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("(5||1)"));
  END_IT

--FILE boolean_eql_match_node.g--
5 = 1
--ENDFILE--
  IT("compiles equality expressions")
    SHOULD_EQUAL(test_compile_file(__TEST_FILE__(boolean_eql_match_node.g)), OK);
    SHOULD_BE_TRUE(test_file_contains("match([5,()=>true])(1);"));
  END_IT

END_DESCRIBE

DESCRIBE(gambit_compiler, "Compiler")

  IT("defines the Compiler struct")
    Compiler p;
    SHOULD_EQUAL(&p, &p);
  END_IT

  IT("sets the current context to main")
    CompilerPtr compiler = init_compiler(OUT_FILE, NULL);
    SHOULD_EQUAL(strcmp(compiler->current_context->name, "main"), 0);
    exit_compiler(compiler);
  END_IT

  status += CSpec_Run(DESCRIPTION(gambit_compiler_compile), CSpec_NewOutputVerbose());

END_DESCRIBE
