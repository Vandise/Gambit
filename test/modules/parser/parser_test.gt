#include "cspec.h"
#include "cspec_output_header.h"
#include "cspec_output_verbose.h"
#include "cspec_output_unit.h"

#include "test/macros.h"
#include "modules/parser/parser_module.h"
#include "modules/scanner/scanner_module.h"

extern int status;

DESCRIBE(gambit_parser_next_token, "Parser - next_token")

  IT("returns and sets the next token")
    TokenArray tokens;
    init_token_array(&tokens, 2);

    Token ts[2] = {
      { .line_number = 1 },
      { .line_number = 2 }
    };

    for (int i = 0; i < 2; i++) {
      insert_token_array(&tokens, ts[i]);  
    }

    Parser* p = init_parser(&tokens);
    SHOULD_EQUAL(p->current_token->line_number, 1);  
    SHOULD_EQUAL((next_token(p))->line_number, 2);
    SHOULD_EQUAL(p->current_token->line_number, 2);

    exit_parser(p);
    free_token_array(&tokens);
  END_IT

END_DESCRIBE

DESCRIBE(gambit_parser_peek_token, "Parser - peek_token")
  
  IT("returns N tokens ahead")
    TokenArray tokens;
    init_token_array(&tokens, 2);

    Token ts[6] = {
      { .line_number = 1 },
      { .line_number = 2 },
      { .line_number = 3 },
      { .line_number = 4 },
      { .line_number = 5 },
      { .line_number = 6 }
    };

    for (int i = 0; i < 6; i++) {
      insert_token_array(&tokens, ts[i]);  
    }

    Parser* p = init_parser(&tokens);
 
    SHOULD_EQUAL(p->current_token->line_number, 1); 
    SHOULD_EQUAL((peek_token(p, 3))->line_number, 4);

    exit_parser(p);
    free_token_array(&tokens);
  END_IT

END_DESCRIBE

DESCRIBE(gambit_parser_init_parser, "Parser - init_parser")

  IT("sets the token_array")
    TokenArray tokens;
    init_token_array(&tokens, 10);
    Parser* p = init_parser(&tokens);

    SHOULD_EQUAL(p->token_array, &tokens);

    exit_parser(p);
    free_token_array(&tokens);
  END_IT

END_DESCRIBE

DESCRIBE(gambit_parser_parse, "Parser - parse")

  IT("recognizes a declaration as a program")
    Scanner* scanner = init_scanner(__TEST_FILE__(declare_match_constant.g));
    do {
      get_token(scanner);
      commit_token(scanner);
    } while (scanner->current_token.token != T_END_OF_FILE && scanner->current_token.token != T_ERROR);

    Parser* p = init_parser(get_tokens(scanner));

    parse(p);

    SHOULD_BE_FALSE(p->errored);
    SHOULD_EQUAL(p->root_node->type, NOOP_NODE);
    SHOULD_EQUAL(p->root_node->next->type, VARIABLE_DECLARATION_NODE);
    SHOULD_EQUAL(p->root_node->next->next, NULL);

    exit_parser(p);
    exit_scanner(scanner);
  END_IT

  IT("recognizes an expression as a program")
    Scanner* scanner = init_scanner(__TEST_FILE__(exp_math_precedence.g));
    do {
      get_token(scanner);
      commit_token(scanner);
    } while (scanner->current_token.token != T_END_OF_FILE && scanner->current_token.token != T_ERROR);

    Parser* p = init_parser(get_tokens(scanner));

    parse(p);

    SHOULD_BE_FALSE(p->errored);
    SHOULD_EQUAL(p->root_node->type, NOOP_NODE);
    SHOULD_EQUAL(p->root_node->next->type, BINARY_OP_NODE);
    SHOULD_EQUAL(p->root_node->next->next, NULL);

    exit_parser(p);
    exit_scanner(scanner);
  END_IT

--FILE terminator.g--


--ENDFILE--

  IT("recognizes a terminator as a program")
    Scanner* scanner = init_scanner(__TEST_FILE__(terminator.g));
    do {
      get_token(scanner);
      commit_token(scanner);
    } while (scanner->current_token.token != T_END_OF_FILE && scanner->current_token.token != T_ERROR);

    Parser* p = init_parser(get_tokens(scanner));

    parse(p);

    SHOULD_BE_FALSE(p->errored);
    SHOULD_EQUAL(p->root_node->type, NOOP_NODE);
    SHOULD_EQUAL(p->root_node->next->type, NOOP_NODE);
    SHOULD_EQUAL(p->root_node->next->next, NULL);

    exit_parser(p);
    exit_scanner(scanner);
  END_IT

--FILE compound_declarations.g--
let($x:Integer, $y:Integer) = 2019

2015
--ENDFILE--

  IT("recognizes compound declarations  as a program")
    Scanner* scanner = init_scanner(__TEST_FILE__(compound_declarations.g));
    do {
      get_token(scanner);
      commit_token(scanner);
    } while (scanner->current_token.token != T_END_OF_FILE && scanner->current_token.token != T_ERROR);

    Parser* p = init_parser(get_tokens(scanner));

    parse(p);

    SHOULD_BE_FALSE(p->errored);

    SHOULD_EQUAL(p->root_node->type, NOOP_NODE);
    SHOULD_EQUAL(p->root_node->next->type, VARIABLE_DECLARATION_NODE);
    SHOULD_EQUAL(p->root_node->next->next->type, VARIABLE_DECLARATION_NODE);
    SHOULD_EQUAL(p->root_node->next->next->next->type, NOOP_NODE);
    SHOULD_EQUAL(p->root_node->next->next->next->next->type, NOOP_NODE);
    SHOULD_EQUAL(p->root_node->next->next->next->next->next->type, LITERAL_NODE);
    SHOULD_EQUAL(p->root_node->next->next->next->next->next->next, NULL);

    exit_parser(p);
    exit_scanner(scanner);
  END_IT
END_DESCRIBE

DESCRIBE(gambit_parser, "Parser")

  IT("defines the Parser struct")
    Parser p;
    SHOULD_EQUAL(&p, &p);
  END_IT

  status += CSpec_Run(DESCRIPTION(gambit_parser_init_parser), CSpec_NewOutputVerbose());
  status += CSpec_Run(DESCRIPTION(gambit_parser_next_token), CSpec_NewOutputVerbose());
  status += CSpec_Run(DESCRIPTION(gambit_parser_peek_token), CSpec_NewOutputVerbose());
  status += CSpec_Run(DESCRIPTION(gambit_parser_parse), CSpec_NewOutputVerbose());

END_DESCRIBE
